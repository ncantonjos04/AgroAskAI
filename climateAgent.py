import os 
import re
import json
import asyncio
import requests
import functools
import pandas as pd
from pathlib import Path
from dotenv import load_dotenv
from openai import AsyncOpenAI

from azure.identity import DefaultAzureCredential
from azure.ai.projects import AIProjectClient 

from semantic_kernel.functions.kernel_arguments import KernelArguments
from semantic_kernel.agents import ChatCompletionAgent, AgentGroupChat
from semantic_kernel.agents.strategies import (
    KernelFunctionSelectionStrategy,
    KernelFunctionTerminationStrategy
)
from semantic_kernel.kernel import Kernel
from semantic_kernel.connectors.ai.open_ai import OpenAIChatCompletion
from semantic_kernel.contents import AuthorRole, ChatMessageContent
from semantic_kernel.functions import KernelFunctionFromPrompt, kernel_function


env_path = Path(__file__).resolve().parent.parent / '.env'
load_dotenv(dotenv_path=env_path)

project_endpoint = os.getenv('AZURE_AI_PROJECT_ENDPOINT')
connection_name = os.getenv('AZURE_STORAGE_CONNECTION_NAME')

# Connect to the NASA POWER API to get accurate weather data in the chosen location
# returns Total Precipitation (T2M) and Temperature at 2 Meters (T2M)

@kernel_function
async def get_NASA_data (latitude: float, longitude: float, start_year: int, end_year: int):
    def blocking_fetch():
    # Connect to NASA POWER API with url using the above parameters
        base_url = (
            f"https://power.larc.nasa.gov/api/temporal/monthly/point?"
            f"start={start_year}&end={end_year}"
            f"&latitude={latitude}&longitude={longitude}"
            f"&community=ag"
            f"&parameters=T2M,PRECTOT"
            f"&format=csv&header=false"
        )

    # Write results to a .txt file  (including the header)
        response = requests.get(base_url)
        data = response.text
        with open('./datasets/weather_data.txt', "a") as file:
            file.write(f"{data}\n")
        
    
        #Add/Update the weather_data.txt to the climateDatabase (AzureStorage)
#       script_dir = os.path.dirname(os.path.abspath(__file__))
#       data_folder = os.path.join(script_dir, "datasets")

#        with DefaultAzureCredential() as credential:
#            with AIProjectClient (endpoint = project_endpoint,credential=credential) as client:
# 
            # search for, then increment dataset version by 1
#                versions = []
#              for d in client.datasets.list():
#                    if d.name == "climateDatabase":
#                       try:
#                          versions.append(float(d.version))
#                      except ValueError:
#                          pass  # skip non-numeric versions
#             latest_version = max(versions, default=0.0)
#             new_version = str(latest_version + 1.0)

#               dataset = client.datasets.upload_folder(
#                  name = "climateDatabase",
#                  version = new_version,
#                  folder=data_folder,
#                  connection_name=connection_name,
#                  file_pattern=re.compile(r"\.(txt|csv|md)$", re.IGNORECASE)
#                  )
        return data
    data = await asyncio.get_event_loop().run_in_executor(None, blocking_fetch)
    return data
        

    

def create_kernel_with_chat_completion() -> Kernel:
    kernel = Kernel()

    client = AsyncOpenAI(
        api_key=os.getenv("GITHUB_TOKEN"),
        base_url= "https://models.inference.ai.azure.com/")
    
    kernel.add_service(
        OpenAIChatCompletion(
            ai_model_id="gpt-4o-mini",
            async_client=client
        )
    )

    kernel.add_function(
        plugin_name="climate_tools",
        function_name = "get_NASA_data", 
        function  = get_NASA_data)

    return kernel



async def main():

    kernel = create_kernel_with_chat_completion()
# Prompt Agent
    PROMPT_NAME = "PromptAgent"
    PROMPT_INSTRUCTIONS = """
    You are an AI chat agent designed to help users address the challenges of climate change, with a focus on crop failure and droughts.

    == Objective ==
    Your primary goal is to:
    1. Provide accurate weather and drought predictions.
    2. Offer relevant adaptation strategies in response to these conditions to help local crop and livestock farmers.

    == Agent Collaboration ==
    You will interact with two other agents to accomplish this:

    - **WeatherAgent**: Provides weather and drought forecasts.
    - **SolutionReviewerAgent**: Evaluates adaptation solutions generated by the SolutionAgent. These solutions respond directly to the weather forecasts and include advice for farmers (both livestock and crop) on how to adapt to predicted conditions.

    == Responsibilities ==
    - Do NOT CALL any kernel functions
    - When users ask about **weather predictions**, you should query the **WeatherAgent** for accurate, up-to-date forecasts (e.g., rainfall patterns, drought likelihood).
    - When users ask for **solutions or farming advice**, you should consult the **SolutionReviewerAgent** to get reviewed and reliable adaptation strategies suited for climate conditions.

    - Keep your answers clear and helpful.
    - Do not give solutions with the first message, allow the SolutionAgent and the SolutionReviewerAgent to talk first before giving a response. 
    - Do not give weather data obtained by the WeatherAgent.
    - Do not mention the use of any other agents. You can say that you are fetching information like the weather, but do not say that you need to check in with the WeatherAgent or the SolutionAgent or the SolutionReviewerAgent. The only thing you should be providing
        is the final solution after the other agents talk.
    - You are not the one coming up with a solution, it is the SolutionAgent and SolutionReviewerAgent that is doing that. Your only job is to provide the answers that they give after they finalize an answer at the end of the conversation. You should be the last message.
    - Only speak again after the SolutionReviewerAgent gives clear approval.
    - When that happens, summarize the solution, include any final recommendations it gave in its most recent message, and indicate the conversation is complete by explicitly saying "This conversation is complete."
    """
    prompt_agent = ChatCompletionAgent(
        kernel = kernel,
        name = PROMPT_NAME,
        instructions = PROMPT_INSTRUCTIONS
    )
    #Parse Agent

    PARSE_NAME = "ParseAgent"
    PARSE_INSTRUCTIONS = """
    You are an AI agent whose job is to extract structured weather query information from a user's natural language request. You will then provide this information in JSON format so it can be passed to the WeatherAgent.

    == Your Responsibilities ==
    Given a user input, extract the following information:

    1. **Latitude and Longitude** of the location requested.
    2. A **start year** and **end year** for the time range requested by the user.
        - If the user does not specify dates, use the default values:
        - start_year = 2015
        - end_year = 2025

    You will receive user input or AI output text. Extract and parse into a JSON with these fields:

        - "latitude": number or null
        - "longitude": number or null
        - "start_year": integer or null
        - "end_year": integer or null
        
        Output only valid JSON, no extra text.

        Example:

        {
        "latitude": -1.369,
        "longitude": 38.016,
        "start_year": 2020,
        "end_year": 2024,
        }
    """

    parse_agent = ChatCompletionAgent(
        kernel = kernel,
        name=PARSE_NAME,
        instructions=PARSE_INSTRUCTIONS
    )
# Weather Prediction Agent
    WEATHER_NAME = "WeatherAgent"
    WEATHER_INSTRUCTIONS = """
    You are an AI agent designed to provide accurate weather predictions. 

    ==Tools==
    The only tool you have access to in the kernel is the get_NASA_data() function, which will provide you with the following data about the coordinates of the location the user is asking about:
    - T2M (Monthly average temperature of the location at 2 meters)
    - PRECTOT (Monthly total precipitation)
    Use NO OTHER TOOL. The only function you should call is the get_NASA_data() function.

    == Objective ==
    Your primary goal is to provide weather and drought predictions. You will provide this information to PromptAgent to provide weather and drought information and to 
    SolutionAgent in order for it to come up with viable solutions and adaptations for agricultural farmers. Keep it brief, up to 2 lines.
    
    """

    weather_agent = ChatCompletionAgent(
        kernel = kernel,
        name= WEATHER_NAME,
        instructions = WEATHER_INSTRUCTIONS,
    )

# Solution/Adaptation Agent
    SOLUTION_NAME = "SolutionAgent"
    SOLUTION_INSTRUCTIONS = """

    You are an AI agent tasked with generating effective and practical agricultural adaptation strategies for farmers.

    == Objective ==
    Your goal is to:
    1. Provide clear, actionable solutions to help farmers mitigate the impacts of predicted weather conditions, especially drought and crop failure risks.
    2. Suggest both crop and livestock management techniques that suit the local climate and socio-economic conditions.
    3. Recommend sustainable practices to improve resilience and productivity under changing weather patterns.

    == Inputs ==
    You will receive detailed weather and drought forecasts from the WeatherAgent, including temperature and precipitation trends.
    - Do NOT CALL any kernel functions

    == Output ==
    Your responses should include:
    - Specific farming techniques (e.g., drought-resistant crops, water conservation methods).
    - Livestock care advice adapted to forecasted weather conditions.
    - Soil and water management practices suitable for semi-arid environments.
    - Community or policy-level adaptation recommendations, if relevant.

    Focus on practical advice that local farmers in Kitui can implement to reduce risk and improve yields under climate stress.
    Only provide a single recommendation per response.
    You're laser focused on the goal at hand.
    Don't waste time with chit chat.
    Consider suggestions when refining an idea.
    Keep it brief, up to 2 lines.

    Keep your answers clear, concise, and grounded in the local context.
    """

    solution_agent = ChatCompletionAgent(
        kernel = kernel,
        name = SOLUTION_NAME,
        instructions = SOLUTION_INSTRUCTIONS
    )

# Solution Reviewer Agent
    REVIEWER_NAME = "SolutionReviewerAgent"
    REVIEWER_INSTRUCTIONS ="""
    You are an AI agent called the SolutionReviewerAgent.

    == Objective ==
    Your primary task is to critically evaluate agricultural adaptation solutions proposed by the SolutionAgent. 
    You assess whether the solutions are practical, contextually relevant, and scientifically sound for farmers considering 
    local climate conditions, socio-economic factors, and predicted weather patterns.

    == Responsibilities ==
    - Review each adaptation strategy for clarity, feasibility, and effectiveness.
    - Ensure solutions are aligned with the semi-arid environment, addressing drought and crop failure risks.
    - Confirm that recommendations cover crop management, livestock care, water conservation, and soil health where appropriate.
    - Provide constructive feedback or suggest improvements to enhance the solution's applicability and impact.
    - Validate that each recommendation is actionable by local farmers with available resources.
    - Reject or flag solutions that are impractical, too generic, or not grounded in local realities.
    - If the solution meets all of the requirements and that there are no further improvements or recommendations to make to it, state that it is approved by explicitly stating "This solution is completely approved."
    - If not, provide insight on how to refine the recommendation without using a specific example. 
    - Only say the word "approved" when the SolutionAgent has recommended the best solution/adaptation.
    - Do NOT CALL any kernel functions
    == Output ==
    - Provide a concise evaluation highlighting strengths and any concerns.
    - Suggest specific refinements or alternative approaches if needed.
    - Keep it brief, up to 2 lines.
    - Approve the solution if it meets all criteria clearly by explicitly stating "This solution is completely approved."

    Maintain a professional, objective, and supportive tone aimed at helping local farmers adapt effectively to climate challenges.
    """
    reviewer_agent = ChatCompletionAgent(
        kernel = kernel,
        name=REVIEWER_NAME,
        instructions = REVIEWER_INSTRUCTIONS
    )

    termination_function = KernelFunctionFromPrompt(
        function_name="termination",
        prompt="""
        Determine if the conversation is complete.

        Criteria:
        1. The SolutionReviewerAgent has stated explicitly "This solution is completely approved." and has no further recommendations or concerns.
        Do not count messages that include phrases like "not approved," "needs improvement," "almost approved," or "would be approved if...".
        2. The most recent message must be from PromptAgent. The PromptAgent must have said "This conversation is complete."

        If both conditions are met, return: yes
        Otherwise, return: no

        History:
        {{$history}}
        """
    )



    selection_function = KernelFunctionFromPrompt(
            function_name="selection",
            prompt=f"""
            Determine which participant takes the next turn in a conversation based on the the most recent participant.
            State only the name of the participant to take the next turn.
            If the conversation is complete, respond with exactly "none"
            No participant should take more than one turn in a row.
            
            Choose only from these participants:
            - {PROMPT_NAME}
            - {SOLUTION_NAME}
            - {REVIEWER_NAME}
            
            Always follow these rules when selecting the next participant, each conversation should be at least 4 turns:
            - After user input, it is {PROMPT_NAME}'s turn.
            - After {SOLUTION_NAME} replies, it is {REVIEWER_NAME}'s turn.
            - After {REVIEWER_NAME} provides feedback:
                - If the message explicitly includes "This solution is completely approved.", then {PROMPT_NAME} responds next and ends the conversation.
                - Otherwise, {SOLUTION_NAME} responds next.
            - NEVER select the same agent twice in a row.
            - After {PROMPT_NAME} speaks for the second and says "This conversation is complete.", the conversation is done.
            - Do NOT CALL any kernel functions
            History:
            {{{{$history}}}}
            """
        )


    # Create the AgentGroupChat

    chat = AgentGroupChat(
        agents = [prompt_agent, weather_agent, solution_agent, reviewer_agent, parse_agent],
        termination_strategy=KernelFunctionTerminationStrategy(
            agents=[reviewer_agent],
            function=termination_function,
            kernel=kernel,
            result_parser=lambda result: str(result.value).strip().lower() == "yes",
            history_variable_name="history",
            maximum_iterations=6,
        ),
        selection_strategy=KernelFunctionSelectionStrategy(
            function=selection_function,
            kernel = kernel,
            result_parser=lambda result: (
                None if str(result.value).strip().lower() == "none" else
                str(result.value[0]) if result.value and len(result.value) > 0 else None
            ),
            agent_variable_name="agents",
            history_variable_name="history",
        )
    )

    # User Input
    user_input = "What are the weather issues in Bayonne, New Jersey and what can farmers do to protect their crops?"
    print(f"User Prompt: {user_input}")

    # Logging the agent conversation
    # Create a DataFrame
    input_id = pd.read_csv('input.csv')['InputID'].astype(int).max() +1
    sequence_number = 1 
    # Track inputs and label them with IDs
    input_df = pd.DataFrame( columns = ['InputID', 'Statement'])
    input_df.loc[len(input_df)] = {
        'InputID': input_id,
        'Statement': user_input
    }
    # Put this dataframe in a csv file
    input_df.to_csv('input.csv', index=False, mode='a', header=False)
    

    output_df = pd.DataFrame( columns = ['InputID', 'SequenceNumber', 'AgentName', 'Output'])
    output_list = list()
    
    # Begin the conversaton. Give the user message to the agent
    await chat.add_chat_message(ChatMessageContent(role=AuthorRole.USER, content=user_input))

    # Parse the user_input to find the paramters for get_NASA_data so weather agent can use it.
    responses = []
    async for response in parse_agent.invoke(messages=user_input):
        responses.append(response)

    parsed = json.loads(responses[0].content.content)  # Now this should work

    latitude = parsed["latitude"]
    longitude = parsed["longitude"]
    start_year = parsed["start_year"]
    end_year = parsed["end_year"]

    args = KernelArguments(
    latitude=latitude,
    longitude=longitude,
    start_year=start_year,
    end_year=end_year
    )

    await kernel.invoke(
        plugin_name="climate_tools",
        function_name="get_NASA_data",
        arguments=args
    )

    weather_context = (
    f"The location is at latitude {latitude}, longitude {longitude}. "
    f"The requested weather period is from {start_year} to {end_year}."
)

    await chat.add_chat_message(ChatMessageContent(
        role=AuthorRole.USER,
        content=weather_context
    ))

    async for content in chat.invoke():
        # Save output
        output_list = [input_id, sequence_number, content.name, content.content]
        output_Series = pd.Series(output_list, index = ['InputID', 'SequenceNumber', 'AgentName', 'Output'])
        output_df = pd.concat([output_df, output_Series.to_frame().T], ignore_index=True)
        sequence_number += 1

        print(f"==={content.name or '*'}===: '{content.content}\n'")

        if (
            "This conversation is complete." in content.content
            and content.name == "PromptAgent"
        ):
            chat.is_complete = True
            break

    
    output_df.to_csv('output.csv', index=False, mode='a')
    print(f"# IS COMPLETE: {chat.is_complete}")

if __name__ == "__main__":
    asyncio.run(main())